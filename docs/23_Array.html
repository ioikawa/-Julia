<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>配列: Array · Julia言語 講義資料</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Julia言語 講義資料</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">はじめに</a></li><li><a class="tocitem" href="01_Juliaの起動.html">Juliaの実行環境</a></li><li><a class="tocitem" href="10_基本機能.html">基本機能</a></li><li><a class="tocitem" href="11_変数.html">変数: Variables</a></li><li><a class="tocitem" href="12_型の変換.html">型の変換と昇格</a></li><li><a class="tocitem" href="20_関数.html">関数: Functions</a></li><li><a class="tocitem" href="21_条件分岐.html">条件分岐</a></li><li><a class="tocitem" href="22_ループ.html">ループ処理</a></li><li class="is-active"><a class="tocitem" href="23_Array.html">配列: Array</a><ul class="internal"><li><a class="tocitem" href="#コロンによる配列の抜き出し"><span>コロンによる配列の抜き出し</span></a></li><li><a class="tocitem" href="#配列同士の連結"><span>配列同士の連結</span></a></li><li><a class="tocitem" href="#要素の-push-と-pop"><span>要素の push と pop</span></a></li><li><a class="tocitem" href="#配列の参照とコピー：deepcopy"><span>配列の参照とコピー：<code>deepcopy</code></span></a></li><li><a class="tocitem" href="#浅いコピーと深いコピー"><span>浅いコピーと深いコピー</span></a></li><li><a class="tocitem" href="#配列に対する関数"><span>配列に対する関数</span></a></li><li><a class="tocitem" href="#dot-演算子：要素ごとの操作"><span>dot 演算子：要素ごとの操作</span></a></li><li><a class="tocitem" href="#空の配列"><span>空の配列</span></a></li><li><a class="tocitem" href="#配列の生成"><span>配列の生成</span></a></li><li class="toplevel"><a class="tocitem" href="#配列とループ処理"><span>配列とループ処理</span></a></li><li><a class="tocitem" href="#配列によるforループ"><span>配列によるforループ</span></a></li><li><a class="tocitem" href="#要素番号の取得:-enumerate"><span>要素番号の取得: <code>enumerate</code></span></a></li><li><a class="tocitem" href="#内包表記-(Comprehensions)"><span>内包表記 (Comprehensions)</span></a></li><li><a class="tocitem" href="#BitVector-による部分配列の抽出"><span>BitVector による部分配列の抽出</span></a></li><li><a class="tocitem" href="#特定の値の除去"><span>特定の値の除去</span></a></li></ul></li><li><a class="tocitem" href="30_浮動小数点数.html">浮動小数点数</a></li><li><a class="tocitem" href="31_Pi.html">無限級数の数値計算</a></li><li><a class="tocitem" href="32_NewtonsMethod.html">Newton法</a></li><li><a class="tocitem" href="33_LinearAlgebra.html">線形代数に関する数値計算</a></li><li><a class="tocitem" href="A01_PyPlot.html">PyPlotによるグラフ描画</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="23_Array.html">配列: Array</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="23_Array.html">配列: Array</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ioikawa/EC-julia/blob/main/src/23_Array.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="配列:-[Array](https://docs.julialang.org/en/v1/manual/arrays/)"><a class="docs-heading-anchor" href="#配列:-[Array](https://docs.julialang.org/en/v1/manual/arrays/)">配列: <a href="https://docs.julialang.org/en/v1/manual/arrays/">Array</a></a><a id="配列:-[Array](https://docs.julialang.org/en/v1/manual/arrays/)-1"></a><a class="docs-heading-anchor-permalink" href="#配列:-[Array](https://docs.julialang.org/en/v1/manual/arrays/)" title="Permalink"></a></h1><p>次のように複数の変数を1列に並べて， <code>[...]</code> で囲ったものを配列という．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1, &quot;two&quot; , 3, &quot;z&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Any}:
 1
  &quot;two&quot;
 3
  &quot;z&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(A)   # 配列の要素数を取得</code><code class="nohighlight hljs ansi" style="display:block;">4</code></pre><p>配列の左から<code>i</code>番目の要素にアクセスするには，<code>A[i]</code>と書く．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; begin
       A = [1, &quot;two&quot; , 3, &quot;z&quot;]
       println(A[1])
       println(A[2])
       println(A[3])
       println(A[4])
       end</code><code class="nohighlight hljs ansi" style="display:block;">1
two
3
z</code></pre><p>配列の先頭と末尾の要素はそれぞれ <code>A[begin]</code>, <code>A[end]</code>と書いてアクセスできる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1, &quot;two&quot; , 3, &quot;z&quot;];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[begin]</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[end]</code><code class="nohighlight hljs ansi" style="display:block;">&quot;z&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[end-1]</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><h2 id="コロンによる配列の抜き出し"><a class="docs-heading-anchor" href="#コロンによる配列の抜き出し">コロンによる配列の抜き出し</a><a id="コロンによる配列の抜き出し-1"></a><a class="docs-heading-anchor-permalink" href="#コロンによる配列の抜き出し" title="Permalink"></a></h2><p>例として整数の連番からなる配列を考える．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = collect(1:10)     # A = [1,2, ..., 10]</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10</code></pre><p><code>1:10</code>は1,2,...,10 という範囲を表す． <code>collect()</code>で範囲が配列に変換されたということである．</p><p>次のように書いても同じである．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = Vector(1:10)</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10</code></pre><p>配列の一部分にまとめてアクセスしたい場合は，<code>A[範囲]</code>の形で書く．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = collect(1:10)</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[3:6]</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
 3
 4
 5
 6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[1:3:end]    # 1 から end まで 3刻みの範囲</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
  1
  4
  7
 10</code></pre><h2 id="配列同士の連結"><a class="docs-heading-anchor" href="#配列同士の連結">配列同士の連結</a><a id="配列同士の連結-1"></a><a class="docs-heading-anchor-permalink" href="#配列同士の連結" title="Permalink"></a></h2><p>２つの配列<code>A</code>, <code>B</code> を連結させる場合は，<code>[A; B]</code> あるいは <code>vcat(A,b)</code>とすればよい．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1,2,3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;a&quot;
 &quot;b&quot;
 &quot;c&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [A; B]</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Any}:
 1
 2
 3
  &quot;a&quot;
  &quot;b&quot;
  &quot;c&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vcat(A, B)</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Any}:
 1
 2
 3
  &quot;a&quot;
  &quot;b&quot;
  &quot;c&quot;</code></pre><h2 id="要素の-push-と-pop"><a class="docs-heading-anchor" href="#要素の-push-と-pop">要素の push と pop</a><a id="要素の-push-と-pop-1"></a><a class="docs-heading-anchor-permalink" href="#要素の-push-と-pop" title="Permalink"></a></h2><p>配列の末尾に要素を追加するには <code>push!(配列, 追加する要素)</code>を用いる． 関数名に<code>!</code>がついているのは，引数を変更する関数であることを表している．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1,2,3,&quot;z&quot;];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(A,4)</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Any}:
 1
 2
 3
  &quot;z&quot;
 4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(A,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,[&quot;あ&quot;, &quot;い&quot;, &quot;う&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{Any}:
 1
 2
 3
  &quot;z&quot;
 4
  &quot;a&quot;
  &quot;b&quot;
  &quot;c&quot;
  [&quot;あ&quot;, &quot;い&quot;, &quot;う&quot;]</code></pre><p>配列の末尾から要素を取り出すには <code>pop!</code>を用いる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1,2,3,&quot;z&quot;];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pop!(A)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;z&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A  # 取り出したものは無くなっているはず</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 1
 2
 3</code></pre><p>一部分を取り出したい場合は<code>splice!</code>が使える．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1,2,3,4,5]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
 1
 2
 3
 4
 5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; splice!(A,2:4)   # A[2:4]を取り出す</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 2
 3
 4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A   # 確認のため表示．取り出した部分は残っていない</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 5</code></pre><h2 id="配列の参照とコピー：deepcopy"><a class="docs-heading-anchor" href="#配列の参照とコピー：deepcopy">配列の参照とコピー：<code>deepcopy</code></a><a id="配列の参照とコピー：deepcopy-1"></a><a class="docs-heading-anchor-permalink" href="#配列の参照とコピー：deepcopy" title="Permalink"></a></h2><p>Julia言語では，配列のコピーは <strong>参照コピー</strong>である． つまり，配列の要素が記録されているメモリアドレスのコピーになる． 次の例を見れば参照がどういうものかわかると思う．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [1,2]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = a     # 参照のコピー</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[1] = 100</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @show a, b;  # aを変えるとbも変わる</code><code class="nohighlight hljs ansi" style="display:block;">(a, b) = ([100, 2], [100, 2])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b[2] = 200</code><code class="nohighlight hljs ansi" style="display:block;">200</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @show a, b;  # bを変えるとaも変わる</code><code class="nohighlight hljs ansi" style="display:block;">(a, b) = ([100, 200], [100, 200])</code></pre><p>配列を複製してコピーするには <code>deepcopy()</code>を用いる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [1,2]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = deepcopy(a)     # 配列そのものを複製</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[1] = 100   # bは書き換わらない</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @show a, b;</code><code class="nohighlight hljs ansi" style="display:block;">(a, b) = ([100, 2], [1, 2])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b[2] = 200 　# aは書き換わらない</code><code class="nohighlight hljs ansi" style="display:block;">200</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @show a, b;</code><code class="nohighlight hljs ansi" style="display:block;">(a, b) = ([100, 2], [1, 200])</code></pre><p><code>deepcopy()</code>は配列がそのまま複製されるので，コピーするのに時間もかかるし，新たにメモリも確保されるので注意．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [1,2]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time b = a    # アロケーション（割当）は行われない</code><code class="nohighlight hljs ansi" style="display:block;">  0.000004 seconds (1 allocation: 64 bytes)
2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time b = deepcopy(a)   # アロケーションされる</code><code class="nohighlight hljs ansi" style="display:block;">  0.000004 seconds (3 allocations: 416 bytes)
2-element Vector{Int64}:
 1
 2</code></pre><h2 id="浅いコピーと深いコピー"><a class="docs-heading-anchor" href="#浅いコピーと深いコピー">浅いコピーと深いコピー</a><a id="浅いコピーと深いコピー-1"></a><a class="docs-heading-anchor-permalink" href="#浅いコピーと深いコピー" title="Permalink"></a></h2><p><code>deepcopy()</code>は配列に格納された値をすべてそのままコピーして新しい配列を生成する． これは通常，<strong>深いコピー (deepcopy)</strong> と呼ばれる． これに対して，<strong>浅いコピー(shallow)</strong> は各要素の参照をコピーする． 違いは次の例を見ればわかる． まずは 深いコピーの挙動を見る．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [1,2,[3,4]]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 1
 2
  [3, 4]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = deepcopy(a)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 1
 2
  [3, 4]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[1] = 100    # 1 を 100に</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[3][1] = 300   # [3,4] を [300, 4] に</code><code class="nohighlight hljs ansi" style="display:block;">300</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @show a, b;   # bは何も変わっていない</code><code class="nohighlight hljs ansi" style="display:block;">(a, b) = (Any[100, 2, [300, 4]], Any[1, 2, [3, 4]])</code></pre><p>次に浅いコピーの場合：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [1,2,[3,4]]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 1
 2
  [3, 4]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = copy(a)     # 浅いコピー</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 1
 2
  [3, 4]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[1] = 100    # 1 → 100に</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[3][1] = 300   # [3,4] → [300, 4] に</code><code class="nohighlight hljs ansi" style="display:block;">300</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @show a, b;   # b[1]は変わっていないが，b[3]は変わっている</code><code class="nohighlight hljs ansi" style="display:block;">(a, b) = (Any[100, 2, [300, 4]], Any[1, 2, [300, 4]])</code></pre><p>深いコピー<code>deepcopy(a)</code>の場合，<code>a</code> に配列が含まれている場合，その配列の中身も丸ごとコピーされて， <code>b = [値, 値, [値, 値]]</code> となる．それに対して， 浅いコピー<code>copy(a)</code> の場合，<code>a</code>内の配列は参照がコピーされる：<code>b = [値，値，参照]</code> ． この結果，<code>b[3]</code>は <code>a[3] = [3,4]</code> への参照となる．</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Julia言語やC/C++, Pythonでは，<code>配列=配列</code>は参照コピーになる． 一方で，FortranやMATLABでは値コピーになるので，注意が必要である． 値コピーの方がコードの挙動がわかりやすいが， 無頓着に書きならべると無駄なアロケーションを発生させてしまう可能性がある． 例えば，与えられた配列<code>a</code>に対して，</p><pre><code class="nohighlight hljs">    b = a        # 参照コピー
    c = a        # 参照コピー
    x = b + c    # 配列生成（アロケーション1回目）</code></pre><p>というコードを考えてみよう．Julia言語の場合は上のコメントに書いてあるとおり， 上2行は参照コピーで，3行目で新たに配列が生成されるので，アロケーションは1回だけである． もし，仮に<code>=</code>が値コピーを行う場合は，上記コードは次と等価になる．</p><pre><code class="nohighlight hljs">    b = copy(a)      # 値コピー（アロケーション1回目）
    c = copy(a)      # 値コピー（アロケーション2回目）
    x = b + c        # 配列生成（アロケーション3回目）</code></pre><p>この場合，アロケーションは3回発生する． （しかし，そもそも <code>x = a + a</code>と書けば無駄なアロケーションは発生しないので， 上の例はあまり意味が無い．もっと良い例はないか？）</p></div></div><h2 id="配列に対する関数"><a class="docs-heading-anchor" href="#配列に対する関数">配列に対する関数</a><a id="配列に対する関数-1"></a><a class="docs-heading-anchor-permalink" href="#配列に対する関数" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1,2,3,4,5]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
 1
 2
 3
 4
 5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(A)      # 配列の要素の総和</code><code class="nohighlight hljs ansi" style="display:block;">15</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; prod(A)     # 総乗</code><code class="nohighlight hljs ansi" style="display:block;">120</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; maximum(A)  # 最大値</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; minimum(A)  # 最小値</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre><h2 id="dot-演算子：要素ごとの操作"><a class="docs-heading-anchor" href="#dot-演算子：要素ごとの操作">dot 演算子：要素ごとの操作</a><a id="dot-演算子：要素ごとの操作-1"></a><a class="docs-heading-anchor-permalink" href="#dot-演算子：要素ごとの操作" title="Permalink"></a></h2><p>配列<code>A</code>の要素ごとに演算，あるいは関数を作用させたい場合， dot演算子 <code>.</code> を用いる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1,2,3,4,5]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
 1
 2
 3
 4
 5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A .+ 1     # [1+1, 2+1, 3+1, 4+1, 5+1]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
 2
 3
 4
 5
 6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A .^ 2     # [1^2, 2^2, 3^2, 4^2, 5^2]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
  1
  4
  9
 16
 25</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sqrt.(A)   # [sqrt(1), sqrt(2), sqrt(3),sqrt(4),sqrt(5)]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 1.0
 1.4142135623730951
 1.7320508075688772
 2.0
 2.23606797749979</code></pre><h2 id="空の配列"><a class="docs-heading-anchor" href="#空の配列">空の配列</a><a id="空の配列-1"></a><a class="docs-heading-anchor-permalink" href="#空の配列" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; empty_array = []   # 空の配列．任意の型の変数を</code><code class="nohighlight hljs ansi" style="display:block;">Any[]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vec = Float64[]    # 要素の型を指定する</code><code class="nohighlight hljs ansi" style="display:block;">Float64[]</code></pre><h2 id="配列の生成"><a class="docs-heading-anchor" href="#配列の生成">配列の生成</a><a id="配列の生成-1"></a><a class="docs-heading-anchor-permalink" href="#配列の生成" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; zeros(3)         # `0`が3個の配列</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ones(3)          # `1`が3個の配列</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fill(&quot;abc&quot;, 3)  # &quot;abc&quot;が3個の配列</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;abc&quot;
 &quot;abc&quot;
 &quot;abc&quot;</code></pre><h1 id="配列とループ処理"><a class="docs-heading-anchor" href="#配列とループ処理">配列とループ処理</a><a id="配列とループ処理-1"></a><a class="docs-heading-anchor-permalink" href="#配列とループ処理" title="Permalink"></a></h1><h2 id="配列によるforループ"><a class="docs-heading-anchor" href="#配列によるforループ">配列によるforループ</a><a id="配列によるforループ-1"></a><a class="docs-heading-anchor-permalink" href="#配列によるforループ" title="Permalink"></a></h2><p><code>A</code>を配列とする．for ループに範囲において<code>x in A</code>と書くと， <code>x</code>が配列<code>A</code>の先頭から末尾へと動くようなループが書ける．</p><pre><code class="language-julia hljs">A = [1,[2],&quot;three&quot;]
for x in A
    @show x
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x = 1
x = [2]
x = &quot;three&quot;</code></pre><h2 id="要素番号の取得:-enumerate"><a class="docs-heading-anchor" href="#要素番号の取得:-enumerate">要素番号の取得: <code>enumerate</code></a><a id="要素番号の取得:-enumerate-1"></a><a class="docs-heading-anchor-permalink" href="#要素番号の取得:-enumerate" title="Permalink"></a></h2><p>カウンタ変数が配列内を動くとき，要素の中身だけでなく番号も取得したい場合もある． その場合は，<code>enumerate()</code> を使う．</p><pre><code class="language-julia hljs">A = [1,[2],&quot;three&quot;]
for (i,x) in enumerate(A)
    @show i,x
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(i, x) = (1, 1)
(i, x) = (2, [2])
(i, x) = (3, &quot;three&quot;)</code></pre><h2 id="内包表記-(Comprehensions)"><a class="docs-heading-anchor" href="#内包表記-(Comprehensions)">内包表記 (Comprehensions)</a><a id="内包表記-(Comprehensions)-1"></a><a class="docs-heading-anchor-permalink" href="#内包表記-(Comprehensions)" title="Permalink"></a></h2><p><code>A = [1,2,3,4,5]</code>のような連番からなる配列は，次のようにして生成できる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [i^2 for i in 1:5]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
  1
  4
  9
 16
 25</code></pre><p>このように配列内で for ループを用いて配列を定義する方法を内包表記という．</p><p><code>A = [1,4,9,16,25]</code>のような <span>$i$</span> 番目の要素が <span>$i^2$</span> であるような配列を， 任意の長さで作成したい場合などは，次のような forループを用いた内包表記が使える．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = 10</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [i^2 for i in 1:n]</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Int64}:
   1
   4
   9
  16
  25
  36
  49
  64
  81
 100</code></pre><h2 id="BitVector-による部分配列の抽出"><a class="docs-heading-anchor" href="#BitVector-による部分配列の抽出">BitVector による部分配列の抽出</a><a id="BitVector-による部分配列の抽出-1"></a><a class="docs-heading-anchor-permalink" href="#BitVector-による部分配列の抽出" title="Permalink"></a></h2><p>例として，実数の要素からなる配列 <code>A</code> から，正の値をもつ要素だけを取り出すことを考える． これは次のようにインデックスに条件式を与えることで実現できる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[A .&gt; 0]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 2
 4</code></pre><p>これの仕組みをもう少し具体的に見てみよう． 配列のインデックスに，<code>0</code> or <code>1</code> の要素のみを含む配列 <code>BitVector</code>を渡すと，<code>1</code>の要素に対応する部分配列を抽出できる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; idx = BitVector([0,0,0,1,1,1])</code><code class="nohighlight hljs ansi" style="display:block;">6-element BitVector:
 0
 0
 0
 1
 1
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[idx]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 -3
  4
 -5</code></pre><p><code>A .&gt; 0</code> は<code>A</code>の要素ごとに 条件式<code>&gt;0</code>を適用し，<code>true</code>の場合は<code>1</code>を，<code>false</code>の場合は<code>0</code>を返す． 結果は <code>BitVector</code>型の配列となる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; idx = A .&gt; 0</code><code class="nohighlight hljs ansi" style="display:block;">6-element BitVector:
 0
 0
 1
 0
 1
 0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[idx]       # A[A.&gt;0]と等価</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 2
 4</code></pre><h2 id="特定の値の除去"><a class="docs-heading-anchor" href="#特定の値の除去">特定の値の除去</a><a id="特定の値の除去-1"></a><a class="docs-heading-anchor-permalink" href="#特定の値の除去" title="Permalink"></a></h2><p>配列から <code>missing</code>（統計データの欠損を表す値）を取り除く処理を考える． 値が<code>missing</code>かどうかの判定には<code>ismissing()</code>を用いる．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ismissing(missing)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ismissing(100)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p><code>.ismissin.(A)</code>で <code>missing</code>を含む要素の<code>BitVector</code>が得られるので，これを <code>.!</code> で反転させて抽出する．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1,2,missing,4,missing]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Union{Missing, Int64}}:
 1
 2
  missing
 4
  missing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[.!ismissing.(A)]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Union{Missing, Int64}}:
 1
 2
 4</code></pre><p><code>.!ismissing.</code>は <code>(!ismissing).</code>と書くこともできるし， <code>map()</code>を使ったほうが場合によっては見やすい．</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1,2,missing,4,missing]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Union{Missing, Int64}}:
 1
 2
  missing
 4
  missing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[(!ismissing).(A)]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Union{Missing, Int64}}:
 1
 2
 4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[map(!, ismissing.(A))]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Union{Missing, Int64}}:
 1
 2
 4</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="22_ループ.html">« ループ処理</a><a class="docs-footer-nextpage" href="30_浮動小数点数.html">浮動小数点数 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 10 July 2023 13:45">Monday 10 July 2023</span>. Using Julia version 1.9.0-beta3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
