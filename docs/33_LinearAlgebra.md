# 線形代数に関する数値計算


## 行列の記述
Julia言語では，行列を扱うために `Matrix{T}` 型が用意されている．`T`は行列の成分の型を表す type parameter である．
例えば，`Matrix{Int64}` は各成分が `Int64` 型の行列になる．
行列は `[...]` の内部に成分を記述して定義する．

成分は行ごとに並べ，セミコロン `;` で区切る．
```@repl
[1 2 3; 4 5 6]

# あるいは，行ごとに改行する．
[1 2 3
 4 5 6]
```

これは成分すべてが `Int64`型であるため，`Matrix{Int64}`型になっているが，
次のように明示的に型を指定することもできる．
```@repl
Float64[1 2 3; 4 5 6]
```

## ベクトル
列ベクトルも同様に `;` で区切る． ベクトルの場合はカンマ `,` で区切ることもできる．

```@repl
[1; 2; 3]
[1, 2, 3]
```

## 行列成分へのアクセス
変数`A`に格納した場合，第$(i,j)$成分にアクセスするには，
`A[i,j]`と書けばよい．
```@repl
A = [11 12 13; 21 22 23]
A[2,1]
```

行列を部分的に抜き出したい場合は，例えば，`:`記号を使う．
```@repl
A = [11 12 13; 21 22 23]
A[:,3] # 第3列
A[2,:] # 第1列
A[1:2,1:2] # (1,1)成分から見て2x2の部分のみを抜き出す
```


## 逆行列
正則行列 `A` の逆行列は `inv(A)` あるいは `A^-1` などで計算できる．

```@repl
inv([1 1 1; 1 2 4; 1 3 9])
```

!!! warning
    `inv(A)*b`でも連立一次方程式の解を計算することは可能だが，効率が悪いので普通は使わない．  
    `inv(A)`は，単位行列で拡大してGaussの消去法で計算する方法（Gauss-Jordan法と呼ぶ）で計算されるが，
    LU分解による計算 `A\b` （＝Gaussの消去法）に比べて計算量の見積もりは約3倍と言われる
    （伊理・藤野「数値計算の常識」（共立出版）の第5章を参照）．


## 行列の生成
次のようなコマンドでも行列を生成できる．

|               |                       |
|:--------------|:----------------------|
|`zeros(m, n)`  | $m \times n$のゼロ行列  |
|`ones(m, n)`   | すべての成分が `1` であるような $m \times n$ 行列 |
|`fill(a, m, n)` | すべての成分が `a` であるような $m \times n$ 行列 |
|`Array{Float64}(undef, m, n)`| 中身が初期化されていない $m \times n$ 行列 |


```@repl
zeros(3,5)
ones(3,5)
fill(pi, 3, 5)
Array{Float64}(undef, 3, 5)
```

!!! note
    型 `T` に対して，`Matrix{T}` は `Array{T,2}` は同じ．
    例えば，`Matrix{Int64}` は `Array{Int64, 2}` と同じ．


## 行列のサイズ取得 `size`
```@repl
size([1 2 3; 4 5 6])     # 2x3の行列
```

## 行列演算
行列 `A`, `B`の和と差は`A + B`, `A - B` で計算される．
積も同様に，

```@repl
A = [1 1; 0 0] 
B = [0 0; 1 1]
A * B     # 行列積の計算例1
B * A     # 行列積の計算例2
A .* B    # 演算子の左に dot `.` を付けると成分ごとの計算になる
[1 2; 3 4].^2   # 成分ごとに2乗する
```

## 転置行列
行列`A`の転置行列は`transepose(A)`で， 随伴（複素共役転置） `adjoint(A)` or `A'`で与えられる．
これらは遅延評価であるので，すぐに実体化したい場合は`Matrix()`などを使えばよい．
```@repl
A = [11 12 13; 21im 22im 23im]
transpose(A)
adjoint(A)
A'  # =adjoint(A)
Matrix(A') # 実体化
```


## 行列の連結
複数の行列をブロック行列の要領で並べれば，簡単に連結することができる．

```@repl
A = zeros(Int, 2,3)    # 見やすくするために， `Int`型にする
B = ones(Int, 2,2)
[A B] # 水平に連結
[A B
 B A]  # 垂直方向にも連結
```


## 内包表記による行列の生成
二重ループを内包表記することで行列を生成

```@repl
M = [10i+j for i in 1:3, j in 1:5]
M[1:end, 1:2]   # 1-2列部分を抜き出す
```

#  連立一次方程式の数値計算

係数行列 `A`, ベクトル `b` に対する 連立一次方程式 `Ax=b` の数値解は `A\b` で計算される．

`\`は left division operator と呼ばれ，`A\b`の場合は**LU分解**で解の計算を行う（詳細については，helpコマンド `? \` を実行してほしい）．
LU分解とは，$A = LU$ となるような下三角行列 $L$ （対角成分はすべて$1$）と上三角行列 $U$ の積に表すことである．
$Ax = b$は  補助変数 $y$ を導入すると
$$
  Uy = b, \quad Lx = y 
$$
という連立方程式と同値になる．数値計算ではこの連立方程式を解いて解を計算するのが一般的な手法となっている．
このLU分解による解の計算は，（線形代数の授業で習う）拡大係数行列$\begin{pmatrix} A &  b \end{pmatrix}$ をGaussの消去法で解くことと等価である．
```@example
A = Float64[1 1 1; 1 2 4; 1 3 9]
b = Float64[0, 1, 0]
x = A\b
```

!!! warning 
    連立一次方程式の数値計算過程では一般に，浮動小数点数の丸め誤差が発生する．
    丸め誤差は微小なものであるが，係数行列によっては，非常に大きな誤差を生むこともあるので注意を要する．
    そのような連立一次方程式を**悪条件**であるという．






# [`LinearAlgebra` パッケージ](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/)の利用
`LinearAlgebra`パッケージには線形代数に関する計算ライブラリが収められている． 
`using LinearAlgebra`で読み込んで使用する．

## トレース，行列式，ランク
```@repl
using LinearAlgebra
A = [1 2; 3 4]
tr(A)
det(A)
rank(A)
```

## 固有値，固有ベクトル
```@repl
using LinearAlgebra
A = [1 -1; 1 1]   
eigvals(A)   # 固有値
v = eigvecs(A)   # 固有ベクトル
v[:,1]'*A*v[:,1]  # 確認
v[:,2]'*A*v[:,2] 

```

## LU分解
```@repl
using LinearAlgebra
A = [2 -1 0 0 0; -1 0 1 0 0; 0 1 0 -1 0; 0 0 -1 0 1; 0 0 0 1 -1]
L,U = lu(A)
L,U = lu(A, NoPivot())   # 行交換 (pivoting) なし
```

## 対角行列
```@example
using LinearAlgebra
diagm([1,2,3])
```

## 三重対角行列

```@example
using LinearAlgebra
T = Tridiagonal([1,2,3], [4,5,6,7], [8,7,9])
Matrix(T)
```

行列`T`の第 `k` 対角成分は `diag(T, k)` で取得できる．

```@repl
using LinearAlgebra
T = Tridiagonal([1,2,3], [4,5,6,7], [8,7,9]);
diag(T,-1)  #ひとつ下
diag(T,0)  # 対角成分
diag(T,1)  # ひとつ上
diag(T,2)　# ２つ上
```
