var documenterSearchIndex = {"docs":
[{"location":"02_浮動小数点数.html#浮動小数点数","page":"浮動小数点数","title":"浮動小数点数","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"計算機において小数は浮動小数点数 (Floating Point Number)として実装されている．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"例えば，10 進数の浮動小数点数は $ 1.234 \\times 10^m $ という形で表されるような数である．ただし，仮数部(1234)の桁数は固定で，指数 m の範囲も有界である． 実際にはこれらに，Inf （無限大） や NaN (Not a Number) が付け加わる． 浮動小数点数の標準規格はIEEE754で策定されている． したがって，計算機における浮動小数点数とその演算は，数学の実数とは異なるものであることに注意．","category":"page"},{"location":"02_浮動小数点数.html#単精度と倍精度","page":"浮動小数点数","title":"単精度と倍精度","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"多くのハードウェアやプログラミング言語で実装されている浮動小数点数は倍精度 (double precision) と単精度 (single precision) の２種類である． Juliaでは，Float64が倍精度に，Float32が単精度に対応している． 特別な理由がない限り，普通は倍精度 Float64 を用いる．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"変数に小数を代入すると，暗黙のうちに Float64 と解釈される．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"x = 0.1\ntypeof(x)","category":"page"},{"location":"02_浮動小数点数.html#指数表記","page":"浮動小数点数","title":"指数表記","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"浮動小数点数は次のように e あるいは E の記号の後ろに指数を表記する．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"0.0000012345","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"1.2345e-6 は $ 1.234 \\times 10^{-6} $ に等しい． 1.0e8 あるいは 1.0e+8 は 10^8の浮動小数点数を表す． 1e8 や 1e+8 と書いても同じことである．整数型にはならないことに注意．","category":"page"},{"location":"02_浮動小数点数.html#丸め誤差","page":"浮動小数点数","title":"丸め誤差","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"浮動小数点数どうしを四則演算して得られた値は浮動小数点数になるとは限らない．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"1.111111111^2   ","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"正確な値は 1111111111^2 = 1234567900987654321 であり，この場合は下4桁分が切り捨てられている． このように演算結果の値に近い浮動小数点数への近似を 丸め (rounding) といい， その際に生じる誤差を 丸め誤差 (rounding error)  という． 丸め誤差は浮動小数点数の計算において，ほぼ必然的に発生する． 丸め方には，正/負の無限大の方向，原点方向，最近点への丸めなどがある．","category":"page"},{"location":"02_浮動小数点数.html#オーバーフロー","page":"浮動小数点数","title":"オーバーフロー","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"倍精度で扱える最大の正の数はfloatmaxで取得できる． 浮動小数点数の演算の結果，このx_maxを超えた場合，無限大を表す Inf となる． このような現象を overflow という．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"x_max = floatmax(Float64)\n2 * x_max ","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"浮動小数点数には先頭桁が0の非正規数も実装されている． 最小の正の非正規数は eps(0.0) で取得できる．演算結果がこれを下回ると 0.0 に丸められることがあり，これを underflow という．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"subnormal_min = eps(0.0)\nsubnormal_min/2  ","category":"page"},{"location":"02_浮動小数点数.html#NaN-(Not-a-Number)","page":"浮動小数点数","title":"NaN (Not a Number)","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"浮動小数点数において不正な演算を行った結果，NaN という記号（正確には特別な浮動小数点数のひとつ）が発生することがある． 例えば，0を0で割ると Nan が発生する．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"0/0","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"ちなみに0以外の正の浮動小数点数をゼロで割るとInfになる．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"1/0","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"note: Note\nPython3ではゼロ除算は ZeroDivisionErrorというエラーを返し，NaNにはなりません． 処理系によっては動作がまちまちなので注意．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"これ以外にも，Infに関する四則演算の結果，NaN が発生することがある． ","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"Inf + Inf\nInf - Inf    # ∞ - ∞\nInf * Inf    \nInf * 0      # ∞ ✕ 0\nInf / Inf    # ∞ ÷ ∞","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"不定形の極限に対応するような演算を行うと NaN が発生すると覚えておけばよい．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"danger: レポート作成上の注意\nInf や NaN の発生を前提としたコード設計はしないようにしてください． Inf や NaNの挙動を完全に把握することは非常に困難で，bug （プログラムにおける予期しない動作やエラー） を生みやすいです．さらに，読み手にとっても理解しにくいコードになります．ちなみにJuliaでは isfinite(x)や isnan(x) で x が Inf あるいは NaN であるかどうかの判定ができます．","category":"page"},{"location":"02_浮動小数点数.html#情報落ち","page":"浮動小数点数","title":"情報落ち","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"浮動小数点数では，非常に小さい値を加えた場合（machine epsilon)，丸めによって値が変化しないことがある． これを情報落ちという．1.0 に eps(1.0) = 2.220446049250313e-16 より小さい値を加えても結果は変わらない． 例えば，","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"1.0 + 1.0e-16","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"上のような例では情報落ちを回避することはできないが， 計算順序を変えることで情報落ちを回避できることがある．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"1.0e-16 + 1.0 - 1.0\n1.0e-16 + (1.0 - 1.0)","category":"page"},{"location":"02_浮動小数点数.html#桁落ち","page":"浮動小数点数","title":"桁落ち","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"近い値の２つの浮動小数点数を引き算すると有効桁数が減少する（桁落ち）． 例えば，12345 - 12344 = 00001 = 1 times 10^4 は，有効桁数5桁どうしを引き算した結果，有効桁数が1桁に減っている． したがって，浮動小数点数の計算では近い値を持つもの同士の減算はできる限り避けたほうがよい．  ","category":"page"},{"location":"02_浮動小数点数.html#桁落ちの例と回避法","page":"浮動小数点数","title":"桁落ちの例と回避法","text":"","category":"section"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"b を正の実数とする． 2次方程式　f(x) = x^2 - 2bx + 1 = 0 の解は，解の公式より","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"  alpha = b - sqrtb^2 - 1 quad beta = b + sqrtb^2 - 1 ","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"と表される． b^2 gg 1の場合， alphaをこのまま計算すると， sqrtb^2 - 1 approx b であるから桁落ちが生じる．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"b = 1e8  # 1e8 = 10^8 \nalpha = b - sqrt(b^2-1)","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"計算値は 0.0 であるが，これが解ではないことは代入してみれば明らかである．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"このような場合でも，式変形で桁落ちを避けることができる．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":" b - sqrtb^2 - 1  = frac1b + sqrtb^2 - 1 ","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"上の式で計算してみると，","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"b = 1e8\nx = 1/(b + sqrt(b^2-1))","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"warning: Warning\n上のalphaの計算式は万能ではなく，b0 かつ b^2 gg 1の場合は桁落ちが発生する．","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"","category":"page"},{"location":"02_浮動小数点数.html","page":"浮動小数点数","title":"浮動小数点数","text":"note: Note\n0.0 と 5.0e-9 は一見して大した違いがないように思われるかもしれませんが，  相対誤差に関してはかなり大きな開きがあります．桁落ちを考慮せずに素朴に計算した場合の数値解 0.0 に対する相対誤差は dfracalpha - 00alpha = 1一方で， 有理化して桁落ちを回避した数値解の相対誤差は， 252times 10^-17 未満であることが示せます．まず，epsilon = 126times 10^-25 とおく．beginaligned\n f(5 times10^-9) = 25 times 10^-18  0 \n f(5 times10^-9 + epsilon) \n = (5 times10^-9 + epsilon)^2 -2times 10^8 epsilon  \n = 25 times 10^-17 + 10^-8 epsilon + epsilon^2  - 252 times 10^-17  0\nendaligned   中間値の定理より， alpha in (5times 10^-9 5times 10^-9+epsilon) となる． よって，5.0e-9 の絶対誤差は alpha - 5times 10^-9  epsilon = 126times 10^-25 と評価される． 5.0e-9 の相対誤差は， dfracalpha - 5times 10^-9alpha  dfrac126times 10^-255times 10^-9 = 252times 10^-17 と評価される．","category":"page"},{"location":"03_関数.html#関数:-[Functions](https://docs.julialang.org/en/v1/manual/functions/)","page":"関数: Functions","title":"関数: Functions","text":"","category":"section"},{"location":"03_関数.html#関数の記述","page":"関数: Functions","title":"関数の記述","text":"","category":"section"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"Julia言語における関数 (function) とは，与えられた引数 (argument)をもとに， 一連の処理を実行し，値を返却するオブジェクトである． 関数は function ... end で定義する．","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"例として，２つの引数 x, y に対して，和 x+y を表示して，かつ和を返却する関数を定義する．","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"function f(x,y)\n    x + y\nend\nf(1,2)","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"これは，数学の関数と同様に形式で書くこともできる．","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"g(x,y) =  x + y\ng(1,2)","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"次のように複数の処理を含む関数は，function ... end を用いたほうがわかりやすい．","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"function h(x,y)\n    z = x + y\n    println(\"$x + $y = $z\")    # 文字列中で`$x`と書くと，変数`x`に置き換わる． \nend\nh(1,2)","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"引数は必ずしも必要ない．","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"function sayhello()\n    println(\"Hello!\")    \nend","category":"page"},{"location":"03_関数.html#戻り値の指定-return","page":"関数: Functions","title":"戻り値の指定 return","text":"","category":"section"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"関数の戻り値は return で明示できる． return に到達した時点で関数から抜ける． ","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"function mult(x,y)\n    println(\"ここは実行される\") \n    return x*y\n    println(\"return後のコードは実行されない\")  \nend\nmult(2,3)","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"単にreturnと書くと，nothingが返却される．","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"function test()\n    println(\"ここは実行される\") \n    return\n    println(\"return後のコードは実行されない\") \nend\n@show test()","category":"page"},{"location":"03_関数.html#オプション引数-(optional-argument)","page":"関数: Functions","title":"オプション引数 (optional argument)","text":"","category":"section"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"引数において，引数名=値と記述するとデフォルト値を指定できる．","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"F(x, y=100) = x + y\nF(1,2)\nF(1) # = F(1,100)\nG(x=1, y) = x+y  # Error! optional argumentは後方のみで利用できる","category":"page"},{"location":"03_関数.html#キーワード引数-(keyword-arugment)","page":"関数: Functions","title":"キーワード引数 (keyword arugment)","text":"","category":"section"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"引数をセミコロン;で区切った場合，; 以降は「キーワード引数」というものになる． キーワード引数の順序は自由であるが，キーワード引数は必ず 引数名=値の形で指定する必要がある． ","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"H(x; a, b) = a*x + b\nH(1,2,3) # これはエラーになる\nH(1, a=2, b=3)\nH(1, b=3, a=2)\nH(a=2, b=3, 1)  \nH(a=2, 1, b=3)  ","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"danger: Danger\nキーワード引数と通常の引数の順番を入れ替えて混ぜることもできますが， 読みにくくなるので本講義では非推奨とします．","category":"page"},{"location":"03_関数.html#数学関数:-[Mathematical-Functions](https://docs.julialang.org/en/v1/base/math/#Mathematical-Functions)","page":"関数: Functions","title":"数学関数: Mathematical Functions","text":"","category":"section"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"Juliaでは基本的な数学関数はほとんど標準で実装されている．","category":"page"},{"location":"03_関数.html#基本的関数","page":"関数: Functions","title":"基本的関数","text":"","category":"section"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"数学関数 Julia\nsqrtx sqrt(x)\nxの絶対値 abs(x)\nxの絶対値の2乗 abs2(x)\nxの符号 sign(x)\nx pmod p mod(x, p)\nxを pで割った余り rem(x, p) or x % p\nxを pで割った商 div(x, p)\n※ 商と余りの両方 divrem(x, p)\n階乗 n factorial(n)\n二項係数beginpmatrix p  q endpmatrix binomial(p,q)","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"note: Note\nabs2はルートの計算がないので，それだけ absより速い．\nrem と% は割られる値が負の場合は動作が異なる．","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"abs(-2)\nsign(-1.23)\nsign(0.0)\nmod(100,3)\nmod(-100, 3)\nmod(3.5, 3)\n3.5 % 3  # mod(3.5, 3) と同じ\nmod(-3.5, 3)\n-3.5 % 3 # mod(-3.5, 3) とは異なるので注意\ndivrem(3.5, 3)\nfactorial(5)\nbinomial(4,2)","category":"page"},{"location":"03_関数.html#三角関数，指数関数，対数関数","page":"関数: Functions","title":"三角関数，指数関数，対数関数","text":"","category":"section"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"数学関数 Julia\nsin(x) sin(x)\ncos(x) cos(x)\ntan(x) tan(x)\narcsin(x) asin(x)\narccos(x) acos(x)\narctan(x) atan(x)\nexp(x) exp(x)\nlog_e(x) log(x)\nlog_10(x) log10(x)\nlog_2(x) log2(x)\nlog_a(x) log(a,x)","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"note: Note\ncotなどの逆数系や，双曲線関数・逆双曲線関数も一通り実装されているがここでは省略する．\nsin(pi x)やcos(pi x) の計算には sinpi(x), cospi(x) といった関数が用意されていてこちらのほうが精度や効率の点で優れている（はず）","category":"page"},{"location":"03_関数.html#複素数","page":"関数: Functions","title":"複素数","text":"","category":"section"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"数学関数 Julia\n実部 mathrmRe z real(z)\n虚部 mathrmIm z imag(z)\nz の絶対値 abs(z)\narg z in (-pi pi angle(z)","category":"page"},{"location":"03_関数.html","page":"関数: Functions","title":"関数: Functions","text":"z = 1.0+sqrt(3)*im    # `im`は虚数単位\nreal(z)\nimag(z)\nabs(z)\nangle(z)/pi\nangle(0)/pi\nangle(-1)/pi\nangle(1im)/pi\nangle(-1im)/pi","category":"page"},{"location":"01_変数.html#変数:-[Variables](https://docs.julialang.org/en/v1/manual/variables/#man-variables)","page":"変数: Variables","title":"変数: Variables","text":"","category":"section"},{"location":"01_変数.html#変数の宣言","page":"変数: Variables","title":"変数の宣言","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"プログラミング言語における変数とは値や文字列などを格納する箱のようなものである．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"Juliaでは 変数名 = 値 の形で記述することで，変数の宣言と値の代入が行われる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"x = 1      # 変数 `x` に `1` を割り当てる\nx = 1;     # 文末のセミコロンで出力を抑制可能","category":"page"},{"location":"01_変数.html#変数に関する四則演算の省略記法","page":"変数: Variables","title":"変数に関する四則演算の省略記法","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"数値*変数の場合，変数の前の*を省略可能．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"x = 1\n2x + 1     ","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"x = x + a は x += a と略記できる． ","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"x = 1\nx += 100","category":"page"},{"location":"01_変数.html#変数の文字列化","page":"変数: Variables","title":"変数の文字列化","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"xを変数とする．文字列リテラル中に$x と書くと， 変数xの値が文字列に埋め込まれる．同様に $(式)と書くと 式が評価（計算）されて文字列として埋め込まれる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"x = 16\nprintln(\"x is $x\")\nprintln(\"The square root of x is $(sqrt(x))\")","category":"page"},{"location":"01_変数.html#@show-マクロ:-[Base.@show](https://docs.julialang.org/en/v1/base/base/#Base.@show)","page":"変数: Variables","title":"@show マクロ: Base.@show","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"@show 変数 or 式 で変数表示できる． 変数のところに式を書くこともできる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"x = 10\n@show x\n@show x^2 x^3 x^4;","category":"page"},{"location":"01_変数.html#@time-マクロ:-[Base.@show](https://docs.julialang.org/en/v1/base/base/#Base.@time)","page":"変数: Variables","title":"@time マクロ: Base.@show","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"与えられた式を実行するのにかかった時間と allocation (メモリ割り当て) の総量を表示する．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"@time sleep(0.5)    # `sleep(t)`は `t`[s]だけ実行を停止するコマンド ","category":"page"},{"location":"01_変数.html#変数のスコープ","page":"変数: Variables","title":"変数のスコープ","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"変数にはスコープ（有効範囲）の違いによってグローバル変数とローカル変数の２種類に分けられる． 通常はどこでも参照可能なグローバル変数になる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"スコープ範囲を作り出すコマンドとして，例えば let ... end がある． let ... end で囲まれた部分で宣言した変数のスコープはコードブロック内に限定される． つまり，暗黙のうちにローカル変数となる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"begin\nfoo = 1          # グローバル変数\n@show foo        # メタ構文変数： 特に意味のない変数名．日本語圏ではhoge, fuga, など．最近ではあまり見かけなくなった．\nlet\n    foo = \"local variable\"    # ローカル変数\n    @show foo\nend\n@show foo       # グローバル変数の foo\nend;","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"warning: Warning\n上の例のように，グローバル変数と同じ名前のローカル変数を宣言すると非常にわかりにくいコードになるので要注意．レポートでは特別な理由がない限り，グローバル変数と同じ名前のローカル変数は使わないようにしてください．また，let ... end を使わなければならないようなコード設計は避けてください．","category":"page"},{"location":"01_変数.html#変数の名前","page":"変数: Variables","title":"変数の名前","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"原則として，変数名は他の人がコードを読んだときにわかりやすい名前をつけるようにする．   「他の人」には1ヶ月後の自分も含まれるので，自分だけしか見ないようなコードでも同様である．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"変数の用途を的確に表す単語やフレーズにすることが望ましい．     変数名は通常は英語で書くが，ローマ字でもわかりやすければ全然問題ない．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"例えば，幅と高さから長方形の面積を計算値をある変数に格納する場合は，","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"   area = width*height","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"よりも","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"   area_rectangle = width*height","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"と書いたほうがより明確になる． 右辺の計算式から変数の意味や用途を推測できるような場合でも，このように はっきり書いてあったほうが読み手にとっては負担が少なくなる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"無駄に長すぎる変数名は逆にわかりにくくしてしまうので注意が必要である．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"    two_dimensional_lebesgue_measure_rectangle = width*height  ","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"もし，一時的にしか使わないのならば，短い変数名にしてコメントで説明を書いておく というのも有効である．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"   S = width*height    # 長方形の面積","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"danger: レポート作成上の注意\nJuliaでは日本語のようなマルチバイト文字も変数名として使用可能ですが，  以下の理由から，できるだけアルファベット表記してください．他言語ではマルチバイト文字が使用可能とは限らない．\nコメントとして日本語表記を想定しているので，変数名と混じると紛らわしい．\n入力に手間がかかる割に，特にメリットがない．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"note: Note\nJuliaにおける命名規則については，スタイルガイドを参照．","category":"page"},{"location":"01_変数.html#変数の型:-[Types](https://docs.julialang.org/en/v1/manual/types/)","page":"変数: Variables","title":"変数の型: Types","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"各変数には型 (type) が定められている．型はどのようなデータを格納しているか表すラベルのようなものである．   変数の型はtypeof()で確認できる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"typeof(1)","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"整数値は自動的にInt64という整数型になる．型の種類についてはすぐ後で説明する．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"Juliaの場合，変数の型は 動的（コンパイル時に自動的に決定される）なので，我々は書かなくてよい． 例えば，Int64型の値を変数に代入すると，その変数は自動的に Int64 型になる． ","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"x = 1       \ntypeof(x)","category":"page"},{"location":"01_変数.html#整数型:-[Integers](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Integers)","page":"変数: Variables","title":"整数型: Integers","text":"","category":"section"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"Int64型は64bit長の符号付き整数 (integer)を表す．整数型にはInt8, Int16, Int32, Int64, Int128がある． 値として1や-200と記述した場合，暗黙的にInt64と解釈される．型を明示して代入することもできる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"x = Int128(1)\ntypeof(x)","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"単にIntとタイプするとシステム環境のbit数に依存して解釈される．[Int64]","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"[Int64]: Document/Integers． ","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"typeof(Int(1))\nSys.WORD_SIZE   # システム環境のbit数の確認","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"整数型はビット数に応じて扱える整数の範囲に限界がある（参考）． typemax(), typemin()で扱える整数の最大値と最小値が具体的に知ることができる．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"typemax(Int64)\ntypemin(Int64)\ntypemax(UInt64)\ntypemin(UInt64)","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"限界の最大値に正の値を足そうとすると，overflowを起こして正常な結果が得られない．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"typemax(Int64) + 1\ntypemax(UInt64) + 1","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"演算の際にoverflowを検知するためには，Base.Checked.checked_addなどが使える．","category":"page"},{"location":"01_変数.html","page":"変数: Variables","title":"変数: Variables","text":"Base.Checked.checked_add(100, 1)  # 100 + 1 = 101 で範囲内で問題なし．\nM = typemax(Int64)\nm = typemin(Int64)\nBase.Checked.checked_add(M, 1)   # M+1 → overflowエラーが発生する\nBase.Checked.checked_mul(M, 2)   # M*2 → overflowエラーが発生する\nBase.Checked.checked_sub(typemin(Int64), 1)   # m-1 → underflowエラーが発生する","category":"page"},{"location":"01_基本機能.html#基本機能","page":"基本機能","title":"基本機能","text":"","category":"section"},{"location":"01_基本機能.html#四則演算","page":"基本機能","title":"四則演算","text":"","category":"section"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"試しに四則演算で計算してみよう．","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"1 + 2    # 足し算\n1 - 2    # 引き算\n2 * 3    # 掛け算\n2 / 3    # 割り算\n10^3     # 累乗． Pythonでは 10**3 と記す． ","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"danger: レポート作成上の注意\n最後の演算結果は ans で参照できますが， レポートでは計算結果を ans で参照しないで，きちんと変数に格納ください．","category":"page"},{"location":"01_基本機能.html#コマンド履歴・補完","page":"基本機能","title":"コマンド履歴・補完","text":"","category":"section"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"実行したコマンドは履歴が保存されている．","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"上矢印キー or ctrl + p ： 一つ前の入力に戻る（過去方向に１つ戻る）\n下矢印キー or ctrl + n ：現在方向に一つ進む","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"TABキーでコマンドやパス（ファイルやフォルダー）の補完ができる． 複数の候補がある場合は一覧が表示される．","category":"page"},{"location":"01_基本機能.html#コメントアウト","page":"基本機能","title":"コメントアウト","text":"","category":"section"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"シャープ記号 # より右側に書かれたコードは行末まで無視される（コメントアウト）．  ","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"begin\n  println(\"1行目\")\n  # println(\"2行目：ここは実行されない\")\n  println(\"3行目\")\nend","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"tip: Tip\n変数の用途やコードの意図など，コメントアウト機能で適宜説明を書くようにしてください．","category":"page"},{"location":"01_基本機能.html#文字列:-[Strings](https://docs.julialang.org/en/v1/manual/strings/)","page":"基本機能","title":"文字列: Strings","text":"","category":"section"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"文字列を表示する簡単な例として，println()を使って hello, world [HW]と表示してみよう． 文字列は double quotes \" ... \"で囲む必要がある．","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"[HW]: Kernighan (1978) によるhello, world","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"println(\"hello, world\")    ","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"println()は自動的に末尾に改行コードが入るが，print()は入らない．","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"print(\"hello\")       # print()は改行なし\nprint(\", world\")\nprintln(\"hello, \\nworld\")   # `\\n`は改行コード","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"複数行の文字列は，\"\"\" ... \"\"\" で囲めばよい．","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"println(\n\"\"\"                                    \n May I tell a story purposing to render clear the ratio circular \n perimeter-breadth, revealing one of the problems most famous in modern \n days, and the greatest man of science anciently known.\n\"\"\"\n) ","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"文字列の連結は * で行う．","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"println(\"hello\" * \", world\")\nprintln(\"Hello! \"^5)\nprintln(\"1\"^19)   # 1のrepunit","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"ちなみに，1を2, 19, 23, 317, 1031個の並べた数は素数である．[repunit]","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"[repunit]: OEIS:A004023","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"note: Note\nPythonなどの他の言語では + で文字列の連結を行います． 公式ドキュメントによると，数学において + は可換な演算子を表すので，Juliaでは 非可換な演算にも用いられる * を文字列の連結に使うようにしたとのこと．","category":"page"},{"location":"01_基本機能.html#[Help-mode](https://docs.julialang.org/en/v1/stdlib/REPL/#Help-mode)","page":"基本機能","title":"Help mode","text":"","category":"section"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"プロンプトで ? キーを押下すると help mode に入る． プロンプトの表示が help?> に変わるので，ここで 調べたいコマンド名を入力すると，説明や使用例が表示される．","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"help?> println\nsearch: println printstyled print sprint isprint\n\n  println([io::IO], xs...)\n\n  Print (using print) xs followed by a newline. If io is not supplied, prints\n  to stdout.\n\n  See also printstyled to add colors etc.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> println(\"Hello, world\")\n  Hello, world\n  \n  julia> io = IOBuffer();\n  \n  julia> println(io, \"Hello\", ',', \" world.\")\n  \n  julia> String(take!(io))\n  \"Hello, world.\\n\"","category":"page"},{"location":"01_基本機能.html","page":"基本機能","title":"基本機能","text":"表示される内容は公式ドキュメントと同じ内容であるようだ．","category":"page"},{"location":"10_Pi.html#無限級数の数値計算","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"","category":"section"},{"location":"10_Pi.html#無限級数","page":"無限級数の数値計算","title":"無限級数","text":"","category":"section"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"実数列a_nの級数","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"  sum_k=1^infty a_n","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"はある実数 S に収束するとする．第 n 項までの部分和を","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"  S_n = sum_k=1^n a_n","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"とおくと，S = lim_n to infty S_n と表されるので， （大きな）正の整数 n に対して S_n は S の近似値になると期待される．","category":"page"},{"location":"10_Pi.html#円周率-pi","page":"無限級数の数値計算","title":"円周率 pi","text":"","category":"section"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"Juliaでは，円周率は数学定数として実装してある．","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"pi           # 遅延評価．実際に計算されるときに適切な形で実体化される．\nFloat64(pi)    # `Float64` 型として実体化","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"後者の16桁の値は一致しているので，この節では円周率の正確な値として参照してよい． 念のため，円周率を16桁まで書き出しておく．","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":" 3.14159_26535_89793","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"ここでは円周率を無限級数で表し，近似値の計算方法について述べる．","category":"page"},{"location":"10_Pi.html#Leibniz（ライプニッツ）の公式","page":"無限級数の数値計算","title":"Leibniz（ライプニッツ）の公式","text":"","category":"section"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"以下の交代級数に関する公式","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":" 1 - dfrac13 + dfrac15 - dfrac17 + cdots = dfracpi4","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"をLeibnizの公式と呼ぶ．これは収束が遅いので，円周率の近似値計算には適さないが，試しに計算してみよう．","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"leibniz(n) = 4*sum([(-1)^i/(2i+1) for i in 0:n])\n#function leibniz(n)\n#   s = 0.0\n#   for i in 0:n\n#       s += (-1)^i/(2i+1)\n#   end\n#   return 4s\n#end\nleibniz(120)","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"120+1項まで計算してやっと3桁まで一致する程度であり，やはり収束速度は非常に遅い．","category":"page"},{"location":"10_Pi.html#Machin（マチン）の公式:-[MathWorld](https://mathworld.wolfram.com/MachinsFormula.html)","page":"無限級数の数値計算","title":"Machin（マチン）の公式: MathWorld","text":"","category":"section"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"Machinの公式","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"   4arctan dfrac15 - arctan dfrac1239 = dfracpi4","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"を用いた円周率の近似値計算は収束が速く，より実用的である． arctan x の原点におけるTaylor展開","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":" arctan x = x - dfracx^33 + dfracx^55 - dfracx^77 + cdots","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"は x le 1 で収束する． この級数にx=15 1239を代入すると，次の級数展開を得る．","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"pi = 16sum_i=0^infty frac(-1)^i2i+1 5^-(2i+1)\n  - 4sum_i=0^infty frac(-1)^i2i+1 239^-(2i+1)","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"これを適当な項数で打ち切れば円周率の近似を与える．","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"note: Note\nMachinの公式で円周率の近似値を計算するプログラムを自分で作成してみよう．  abs(近似値 -  Float64(pi)) < 1e-15が true になれば Float64型に関しては限界近くまで近似できていると判断してください．","category":"page"},{"location":"10_Pi.html#Appendex:-BigFloat型で円周率を表示する","page":"無限級数の数値計算","title":"Appendex: BigFloat型で円周率を表示する","text":"","category":"section"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"任意精度の浮動小数点数を扱うものとして，Juliaでは BigFloat 型が用意してある． BigFloat型で pi を実体化すれば任意の桁数で 円周率を表示できる．","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"setprecision(2600)   # 精度を 2600 bits に設定．\nbig(pi)","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"2600 bits は 10進数に換算すると，およそ782桁 (2600 log_10 2 approx 7827) に相当する． 出力を5桁ごとに区切って整形すると次のようになる．","category":"page"},{"location":"10_Pi.html","page":"無限級数の数値計算","title":"無限級数の数値計算","text":"3.\n14159 26535 89793 23846 26433 83279 50288 41971 69399 37510   \n58209 74944 59230 78164 06286 20899 86280 34825 34211 70679\n82148 08651 32823 06647 09384 46095 50582 23172 53594 08128    \n48111 74502 84102 70193 85211 05559 64462 29489 54930 38196 \n44288 10975 66593 34461 28475 64823 37867 83165 27120 19091\n45648 56692 34603 48610 45432 66482 13393 60726 02491 41273\n72458 70066 06315 58817 48815 20920 96282 92540 91715 36436 \n78925 90360 01133 05305 48820 46652 13841 46951 94151 16094 \n33057 27036 57595 91953 09218 61173 81932 61179 31051 18548\n07446 23799 62749 56735 18857 52724 89122 79381 83011 94912\n98336 73362 44065 66430 86021 39494 63952 24737 19070 21798\n60943 70277 05392 17176 29317 67523 84674 81846 76694 05132 \n00056 81271 45263 56082 77857 71342 75778 96091 73637 17872 \n14684 40901 22495 34301 46549 58537 10507 92279 68925 89235\n42019 95611 21290 21960 86403 44181 59813 62977 47713 09960\n51870 72113 49999 99837 29780 49951 056","category":"page"},{"location":"06_配列.html#配列:-[Array](https://docs.julialang.org/en/v1/manual/arrays/)","page":"配列: Array","title":"配列: Array","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"次のように複数の変数を1列に並べて， [...] で囲ったものを配列という．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1, \"two\" , 3, \"z\"]\nlength(A)   # 配列の要素数を取得","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"配列の左からi番目の要素にアクセスするには，A[i]と書く．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"begin\nA = [1, \"two\" , 3, \"z\"]\nprintln(A[1])\nprintln(A[2])\nprintln(A[3])\nprintln(A[4])\nend","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"配列の先頭と末尾の要素はそれぞれ A[begin], A[end]と書いてアクセスできる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1, \"two\" , 3, \"z\"];\nA[begin]\nA[end]\nA[end-1] ","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"配列の一部分にまとめてアクセスしたい場合は，開始番号:終了番号の形で書く．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1, \"two\" , 3, \"z\"];\nA[1:end-1]","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"empty_array = []   # 空の配列．任意の型の変数を\nvec = Float64[]    # 要素の型を指定する","category":"page"},{"location":"06_配列.html#要素の-push-と-pop","page":"配列: Array","title":"要素の push と pop","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"配列の末尾に要素を追加するには push!(配列, 追加する要素)を用いる． 関数名に!がついているのは，引数を変更する関数であることを表している．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,2,3,\"z\"];\npush!(A,4)\npush!(A,\"a\",\"b\",\"c\",[\"あ\", \"い\", \"う\"])","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"配列の末尾から要素を取り出すには pop!を用いる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,2,3,\"z\"];\npop!(A)\nA  # 取り出したものは無くなっているはず","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"一部分を取り出したい場合はsplice!が使える．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,2,3,4,5]\nsplice!(A,2:4)   # A[2:4]を取り出す\nA   # 確認","category":"page"},{"location":"06_配列.html#配列の参照とコピー：deepcopy","page":"配列: Array","title":"配列の参照とコピー：deepcopy","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"プログラミング言語では，配列のコピーは 参照のコピー，つまり，配列の要素が記録されているメモリアドレスのコピーになる． 次の例を見れば参照がどういうものかわかると思う．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"a = [1,2]\nb = a     # 参照のコピー\na[1] = 100   \n@show a, b;  # 同じ\nb[2] = 200 \n@show a, b;  # 同じ","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"配列を複製してコピーするには deepcopy()を用いる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"a = [1,2]\nb = deepcopy(a)     # 配列そのものを複製\na[1] = 100   # bは書き換わらない \n@show a, b;  \nb[2] = 200 　# aは書き換わらない\n@show a, b;  ","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"deepcopy()は配列がそのまま複製されるので，コピーするのに時間もかかるし，新たにメモリも確保されるので注意．","category":"page"},{"location":"06_配列.html#配列に対する関数","page":"配列: Array","title":"配列に対する関数","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,2,3,4,5]\nsum(A)      # 配列の要素の総和\nprod(A)     # 総乗\nmaximum(A)  # 最大値\nminimum(A)  # 最小値","category":"page"},{"location":"06_配列.html#dot-演算子：要素ごとの操作","page":"配列: Array","title":"dot 演算子：要素ごとの操作","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"配列Aの要素ごとに演算，あるいは関数を作用させたい場合， dot演算子 . を用いる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,2,3,4,5]\nA .+ 1     # [1+1, 2+1, 3+1, 4+1, 5+1]\nA .^ 2     # [1^2, 2^2, 3^2, 4^2, 5^2]\nsqrt.(A)   # [sqrt(1), sqrt(2), sqrt(3),sqrt(4),sqrt(5)]","category":"page"},{"location":"06_配列.html#配列の生成","page":"配列: Array","title":"配列の生成","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"zeros(3)         # `0`が3個の配列\nones(3)          # `1`が3個の配列\nfill(\"abc\", 3)  # \"abc\"が3個の配列","category":"page"},{"location":"06_配列.html#配列とループ処理","page":"配列: Array","title":"配列とループ処理","text":"","category":"section"},{"location":"06_配列.html#配列によるforループ","page":"配列: Array","title":"配列によるforループ","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"Aを配列とする．for ループに範囲においてx in Aと書くと， xが配列Aの先頭から末尾へと動くようなループが書ける．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,[2],\"three\"] \nfor x in A \n    @show x\nend","category":"page"},{"location":"06_配列.html#要素番号の取得:-enumerate","page":"配列: Array","title":"要素番号の取得: enumerate","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"カウンタ変数が配列内を動くとき，要素の中身だけでなく番号も取得したい場合もある． その場合は，enumerate() を使う．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,[2],\"three\"] \nfor (i,x) in enumerate(A) \n    @show i,x\nend","category":"page"},{"location":"06_配列.html#内包表記-(Comprehensions)","page":"配列: Array","title":"内包表記 (Comprehensions)","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,2,3,4,5]のような連番からなる配列は，次のようにして生成できる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [i^2 for i in 1:5]","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"このように配列内で for ループを用いて配列を定義する方法を内包表記という．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,4,9,16,25]のような i 番目の要素が i^2 であるような配列を， 任意の長さで作成したい場合などは，次のような forループを用いた内包表記が使える．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"n = 10\nA = [i^2 for i in 1:n]","category":"page"},{"location":"06_配列.html#BitVector-による部分配列の抽出","page":"配列: Array","title":"BitVector による部分配列の抽出","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"例として，実数の要素からなる配列 A から，正の値をもつ要素だけを取り出すことを考える． これは次のようにインデックスに条件式を与えることで実現できる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i\nA[A .> 0]","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"これの仕組みをもう少し具体的に見てみよう． 配列のインデックスに，0 or 1 の要素のみを含む配列 BitVectorを渡すと，1の要素に対応する部分配列を抽出できる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i\nidx = BitVector([0,0,0,1,1,1])   \nA[idx]  ","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A .> 0 はAの要素ごとに 条件式>0を適用し，trueの場合は1を，falseの場合は0を返す． 結果は BitVector型の配列となる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i\nidx = A .> 0\nA[idx]       # A[A.>0]と等価","category":"page"},{"location":"06_配列.html#特定の値の除去","page":"配列: Array","title":"特定の値の除去","text":"","category":"section"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"配列から missing（統計データの欠損を表す値）を取り除く処理を考える． 値がmissingかどうかの判定にはismissing()を用いる．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"ismissing(missing)\nismissing(100)","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":".ismissin.(A)で missingを含む要素のBitVectorが得られるので，これを .! で反転させて抽出する．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,2,missing,4,missing]\nA[.!ismissing.(A)]   ","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":".!ismissing.は (!ismissing).と書くこともできるし， map()を使ったほうが場合によっては見やすい．","category":"page"},{"location":"06_配列.html","page":"配列: Array","title":"配列: Array","text":"A = [1,2,missing,4,missing]\nA[(!ismissing).(A)]   \nA[map(!, ismissing.(A))]   ","category":"page"},{"location":"A01_PyPlot.html#PyPlotによるグラフ描画","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"","category":"section"},{"location":"A01_PyPlot.html#PyPlot.jl-パッケージによるグラフ描画","page":"PyPlotによるグラフ描画","title":"PyPlot.jl パッケージによるグラフ描画","text":"","category":"section"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"Pythonには matplotlib という有名な描画ライブラリがあり， PyPlotというインターフェースを介してグラフを描画することができる．","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"ここでは，Juliaから PyPlotを呼び出すパッケージ（インターフェース） PyPlot.jl を使ってグラフを描画する方法を説明する．","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"note: Note\nPyPlot.jl は PyPlotのインターフェースなので，基本的には （Pythonの）PyPlotと同じ方法で動作する． 公式のチュートリアル に書いてあるPythonコードをJulia向けに少し書き直せばそのまま動く（はず）．","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"note: Note\nJulia言語の標準的な描画パッケージは現時点では存在しないが， 有名なものとしては Plots.jl というパッケージがある．． Plots.jl は様々な描画ライブラリに対するフロントエンドであり， GR や PyPlot などといった描画ライブラリを呼び出すことができる（このようなライブラリをバックエンドという）． GR は PyPlotに比べて簡単に使えるので便利だが，まだ v1.0未満（現時点で v0.66.0）のためか，細かいところで完成度の低い印象がある．","category":"page"},{"location":"A01_PyPlot.html#準備","page":"PyPlotによるグラフ描画","title":"準備","text":"","category":"section"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"Pythonライブラリを呼び出すためのPyCallと，matplotlibをあらかじめインストールしておく必要がある．","category":"page"},{"location":"A01_PyPlot.html#matplotlibのインストール","page":"PyPlotによるグラフ描画","title":"matplotlibのインストール","text":"","category":"section"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"Python側でmatplotlibのインストールを行う．例えば，pipコマンドで次を実行する．","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"$ pip install matplotlib","category":"page"},{"location":"A01_PyPlot.html#PyCallのインストール","page":"PyPlotによるグラフ描画","title":"PyCallのインストール","text":"","category":"section"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"Julia側でPyCallのインストールを行う． インストールの手順はこちらを参照． 基本的には pkg> add PyCall で問題なくインストールされるが． 環境によってはエラーが発生するようなので要注意．","category":"page"},{"location":"A01_PyPlot.html#PyPlot.jlパッケージの追加","page":"PyPlotによるグラフ描画","title":"PyPlot.jlパッケージの追加","text":"","category":"section"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"PyCallとmatplotlibが適切にインストールされていれば特に問題なく終わるはず．","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"$ julia\njulia> ]  \npkg> add PyPlot\n [...]","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"動作確認として，01times 01内にランダムに10個の点を取り，順番に線を結んだグラフを描いてみる．","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"using PyPlot\nclf()        # 描画のクリア\nplot(rand(10), rand(10), marker=\"o\");\nsavefig(\"plot-test.png\"); ","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"(Image: plot)","category":"page"},{"location":"A01_PyPlot.html#グラフ描画:-plot","page":"PyPlotによるグラフ描画","title":"グラフ描画: plot","text":"","category":"section"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"using PyPlot\n#clf()              # 描画のクリア\nfigure()      # 直前に描いたグラフと重なるのを防ぐため\ngrid()\nx = -2pi:0.1pi:2pi    \nplot(x, sin.(x))  \nsavefig(\"plot-sin.png\")","category":"page"},{"location":"A01_PyPlot.html","page":"PyPlotによるグラフ描画","title":"PyPlotによるグラフ描画","text":"(Image: plot)","category":"page"},{"location":"05_ループ.html#ループ処理","page":"ループ処理","title":"ループ処理","text":"","category":"section"},{"location":"05_ループ.html#for-...-end-ループ","page":"ループ処理","title":"for ... end ループ","text":"","category":"section"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"一連の処理を繰り返し実行したい場合，次のように記述する．","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"for i in 1:5\n   @show i\nend","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"i はカウンタ変数と呼ばれ，指定された範囲を動く． i in 1:5 と書けば i = 1, 2 , ..., 5 と1刻みで動く．  i in 1:5 は i = 1:5 とかいても同じであるが，ここでは in で統一する．","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"刻み（増分）を k に変更したい場合は，i in 1:k:5　と書く．","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"for i in 1:0.5:5    \n    @show i \nend","category":"page"},{"location":"05_ループ.html#多重ループ","page":"ループ処理","title":"多重ループ","text":"","category":"section"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"for ... endループは入れ子にできる．","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"for i in 1:3\n    for j in 1:5\n        @show i, j\n    end\nend","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"　","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"Julia言語では多重ループは次のように書くこともできる．他言語ではサポートされていないかもしれない．","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"for i in 1:3, j in 1:5\n    @show i, j\nend","category":"page"},{"location":"05_ループ.html#ループからの脱出:-break","page":"ループ処理","title":"ループからの脱出: break","text":"","category":"section"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"breakコマンドでループから抜けることができる．","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"s = 0\nfor i in 1:100\n    global s += i\n    @show s\n    if s > 50       # 総和が50を超えたループを抜ける   \n        println(\"break\")\n        break        \n    end\nend","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"ループを抜けずにループの先頭に戻りたい場合は continueコマンドを使う．","category":"page"},{"location":"05_ループ.html","page":"ループ処理","title":"ループ処理","text":"note: Note\nある条件をみたすまでループを際限なく繰り返したい場合は，while ... end が使えます． 数値計算においては，最大反復回数が定められている  for ループを使ったほうが安全です．意図しない無限ループを回避できます． もちろん while ループのほうが適切な場合もありますが，ここではその必要性が無いので for ループのみを用います．","category":"page"},{"location":"11_NewtonsMethod.html#Newton法","page":"Newton法","title":"Newton法","text":"","category":"section"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"Newton法とは，非線形方程式 f(x) = 0 の近似値を求めるための反復解法として最も有名なものである． 1669年に，万有引力で有名な Isaac Newton が 現在のNewton法に相当する方法を考案した．[Yamamoto] ","category":"page"},{"location":"11_NewtonsMethod.html#Newton法のアルゴリズム","page":"Newton法","title":"Newton法のアルゴリズム","text":"","category":"section"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"[Yamamoto]: 山本哲朗，「Newton法とその周辺」, 1985.","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":" f(x) を実数全体で定義された C^1 級の実数値関数（f は微分可能で，導関数 f は連続である）とする．","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"方程式 f(x) = 0 の解 alpha の近似値を，次の漸化式で反復計算する方法を Newton法 あるいはNewton–Raphson法という．","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"x_n+1 = x_n - fracf(x_n)f(x_n) qquad (n ge 0) ","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"ただし，初項 x_0 は適切な値に取り，x=alpha の近傍で f(x) neq 0 が成り立っているとする．[Note1]","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"[Note1]:  f(alpha) neq 0 ならば， x が alpha の十分近くにあるかぎりは f(x) neq 0 が保証される．しかし，「十分近く」が具体的にどれぐらいなのかは一般にはわからない．ちなみに，f(alpha) = 0 でも収束はするが，収束速度は低下する．","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"反復計算は x_n+1を漸化式により計算したとき， 前のステップのx_nとの差の絶対値が十分小さくなったら打ち切るものとする：","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"  x_n+1 - x_n   mathtttol","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"ただし，mathtttol0はあらかじめ決めておいた（小さな値の）定数である．","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"Newton法のアルゴリズムをまとめると次のようになる．","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"x_0 を与える．\nn = 0 1 2  に対して，次の3-4を繰り返す．\nquad x_n+1 を計算する．\nquad x_n+1 - x_n  mathtttol ならばループを抜ける．","category":"page"},{"location":"11_NewtonsMethod.html#Newton法の局所収束性について","page":"Newton法","title":"Newton法の局所収束性について","text":"","category":"section"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"Newton法の反復列は一般には収束するとは限らないが，x_0 が alpha に 十分近くにある場合は 2次収束する ことが知られている．つまり，ある n に依存しない定数 Cが存在し，十分大きな n に対して 次が成り立つ．","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":" x_n+1 - alpha le C x_n - alpha^2","category":"page"},{"location":"11_NewtonsMethod.html","page":"Newton法","title":"Newton法","text":"Newton法の大域的な収束性は一般にはわからない．","category":"page"},{"location":"12_LinearAlgebra.html#線形代数に関する数値計算","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"","category":"section"},{"location":"12_LinearAlgebra.html#行列の記述","page":"線形代数に関する数値計算","title":"行列の記述","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"Julia言語では，行列を扱うために Matrix{T} 型が用意されている．Tは行列の成分の型を表す type parameter である． 例えば，Matrix{Int64} は各成分が Int64 型の行列になる． 行列は [...] の内部に成分を記述して定義する．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"成分は行ごとに並べ，セミコロン ; で区切る．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"[1 2 3; 4 5 6]\n\n# あるいは，行ごとに改行する．\n[1 2 3\n 4 5 6]","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"これは成分すべてが Int64型であるため，Matrix{Int64}型になっているが， 次のように明示的に型を指定することもできる．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"Float64[1 2 3; 4 5 6]","category":"page"},{"location":"12_LinearAlgebra.html#ベクトル","page":"線形代数に関する数値計算","title":"ベクトル","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"列ベクトルも同様に ; で区切る． ベクトルの場合はカンマ , で区切ることもできる．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"[1; 2; 3]\n[1, 2, 3]","category":"page"},{"location":"12_LinearAlgebra.html#行列成分へのアクセス","page":"線形代数に関する数値計算","title":"行列成分へのアクセス","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"変数Aに格納した場合，第(ij)成分にアクセスするには， A[i,j]と書けばよい．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"A = [11 12 13; 21 22 23]\nA[2,1]","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"行列を部分的に抜き出したい場合は，例えば，:記号を使う．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"A = [11 12 13; 21 22 23]\nA[:,3] # 第3列\nA[2,:] # 第1列\nA[1:2,1:2] # (1,1)成分から見て2x2の部分のみを抜き出す","category":"page"},{"location":"12_LinearAlgebra.html#逆行列","page":"線形代数に関する数値計算","title":"逆行列","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"正則行列 A の逆行列は inv(A) あるいは A^-1 などで計算できる．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"inv([1 1 1; 1 2 4; 1 3 9])","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"warning: Warning\ninv(A)*bでも連立一次方程式の解を計算することは可能だが，効率が悪いので普通は使わない．   inv(A)は，単位行列で拡大してGaussの消去法で計算する方法（Gauss-Jordan法と呼ぶ）で計算されるが， LU分解による計算 A\\b （＝Gaussの消去法）に比べて計算量の見積もりは約3倍と言われる （伊理・藤野「数値計算の常識」（共立出版）の第5章を参照）．","category":"page"},{"location":"12_LinearAlgebra.html#行列の生成","page":"線形代数に関する数値計算","title":"行列の生成","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"次のようなコマンドでも行列を生成できる．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":" \nzeros(m, n) m times nのゼロ行列\nones(m, n) すべての成分が 1 であるような m times n 行列\nfill(a, m, n) すべての成分が a であるような m times n 行列\nArray{Float64}(undef, m, n) 中身が初期化されていない m times n 行列","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"zeros(3,5)\nones(3,5)\nfill(pi, 3, 5)\nArray{Float64}(undef, 3, 5)","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"note: Note\n型 T に対して，Matrix{T} は Array{T,2} は同じ． 例えば，Matrix{Int64} は Array{Int64, 2} と同じ．","category":"page"},{"location":"12_LinearAlgebra.html#行列のサイズ取得-size","page":"線形代数に関する数値計算","title":"行列のサイズ取得 size","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"size([1 2 3; 4 5 6])     # 2x3の行列","category":"page"},{"location":"12_LinearAlgebra.html#行列演算","page":"線形代数に関する数値計算","title":"行列演算","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"行列 A, Bの和と差はA + B, A - B で計算される． 積も同様に，","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"A = [1 1; 0 0] \nB = [0 0; 1 1]\nA * B     # 行列積の計算例1\nB * A     # 行列積の計算例2\nA .* B    # 演算子の左に dot `.` を付けると成分ごとの計算になる\n[1 2; 3 4].^2   # 成分ごとに2乗する","category":"page"},{"location":"12_LinearAlgebra.html#転置行列","page":"線形代数に関する数値計算","title":"転置行列","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"行列Aの転置行列はtransepose(A)で， 随伴（複素共役転置） adjoint(A) or A'で与えられる． これらは遅延評価であるので，すぐに実体化したい場合はMatrix()などを使えばよい．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"A = [11 12 13; 21im 22im 23im]\ntranspose(A)\nadjoint(A)\nA'  # =adjoint(A)\nMatrix(A') # 実体化","category":"page"},{"location":"12_LinearAlgebra.html#行列の連結","page":"線形代数に関する数値計算","title":"行列の連結","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"複数の行列をブロック行列の要領で並べれば，簡単に連結することができる．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"A = zeros(Int, 2,3)    # 見やすくするために， `Int`型にする\nB = ones(Int, 2,2)\n[A B] # 水平に連結\n[A B\n B A]  # 垂直方向にも連結","category":"page"},{"location":"12_LinearAlgebra.html#内包表記による行列の生成","page":"線形代数に関する数値計算","title":"内包表記による行列の生成","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"二重ループを内包表記することで行列を生成","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"M = [10i+j for i in 1:3, j in 1:5]\nM[1:end, 1:2]   # 1-2列部分を抜き出す","category":"page"},{"location":"12_LinearAlgebra.html#連立一次方程式の数値計算","page":"線形代数に関する数値計算","title":"連立一次方程式の数値計算","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"係数行列 A, ベクトル b に対する 連立一次方程式 Ax=b の数値解は A\\b で計算される．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"\\は left division operator と呼ばれ，A\\bの場合はLU分解で解の計算を行う（詳細については，helpコマンド ? \\ を実行してほしい）． LU分解とは，A = LU となるような下三角行列 L （対角成分はすべて1）と上三角行列 U の積に表すことである． Ax = bは  補助変数 y を導入すると $   Uy = b, \\quad Lx = y  $ という連立方程式と同値になる．数値計算ではこの連立方程式を解いて解を計算するのが一般的な手法となっている． このLU分解による解の計算は，（線形代数の授業で習う）拡大係数行列beginpmatrix A   b endpmatrix をGaussの消去法で解くことと等価である．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"A = Float64[1 1 1; 1 2 4; 1 3 9]\nb = Float64[0, 1, 0]\nx = A\\b","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"warning: Warning\n連立一次方程式の数値計算過程では一般に，浮動小数点数の丸め誤差が発生する． 丸め誤差は微小なものであるが，係数行列によっては，非常に大きな誤差を生むこともあるので注意を要する． そのような連立一次方程式を悪条件であるという．","category":"page"},{"location":"12_LinearAlgebra.html#[LinearAlgebra-パッケージ](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/)の利用","page":"線形代数に関する数値計算","title":"LinearAlgebra パッケージの利用","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"LinearAlgebraパッケージには線形代数に関する計算ライブラリが収められている．  using LinearAlgebraで読み込んで使用する．","category":"page"},{"location":"12_LinearAlgebra.html#トレース，行列式，ランク","page":"線形代数に関する数値計算","title":"トレース，行列式，ランク","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"using LinearAlgebra\nA = [1 2; 3 4]\ntr(A)\ndet(A)\nrank(A)","category":"page"},{"location":"12_LinearAlgebra.html#固有値，固有ベクトル","page":"線形代数に関する数値計算","title":"固有値，固有ベクトル","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"using LinearAlgebra\nA = [1 -1; 1 1]   \neigvals(A)   # 固有値\nv = eigvecs(A)   # 固有ベクトル\nv[:,1]'*A*v[:,1]  # 確認\nv[:,2]'*A*v[:,2] \n","category":"page"},{"location":"12_LinearAlgebra.html#LU分解","page":"線形代数に関する数値計算","title":"LU分解","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"using LinearAlgebra\nA = [2 -1 0 0 0; -1 0 1 0 0; 0 1 0 -1 0; 0 0 -1 0 1; 0 0 0 1 -1]\nL,U = lu(A)\nL,U = lu(A, NoPivot())   # 行交換 (pivoting) なし","category":"page"},{"location":"12_LinearAlgebra.html#対角行列","page":"線形代数に関する数値計算","title":"対角行列","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"using LinearAlgebra\ndiagm([1,2,3])","category":"page"},{"location":"12_LinearAlgebra.html#三重対角行列","page":"線形代数に関する数値計算","title":"三重対角行列","text":"","category":"section"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"using LinearAlgebra\nT = Tridiagonal([1,2,3], [4,5,6,7], [8,7,9])\nMatrix(T)","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"行列Tの第 k 対角成分は diag(T, k) で取得できる．","category":"page"},{"location":"12_LinearAlgebra.html","page":"線形代数に関する数値計算","title":"線形代数に関する数値計算","text":"using LinearAlgebra\nT = Tridiagonal([1,2,3], [4,5,6,7], [8,7,9]);\ndiag(T,-1)  #ひとつ下\ndiag(T,0)  # 対角成分\ndiag(T,1)  # ひとつ上\ndiag(T,2)　# ２つ上","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"using Dates; today()","category":"page"},{"location":"index.html#はじめに","page":"はじめに","title":"はじめに","text":"","category":"section"},{"location":"index.html#Julia言語とは","page":"はじめに","title":"Julia言語とは","text":"","category":"section"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"Julia言語 は 数値計算向けに設計された汎用プログラミング言語 である．\n数値計算プログラムが書きやすく，実行速度も速い．\n比較的新しい言語である：2018年にバージョン 1.0 がリリースされ[1]，言語仕様が正式なものとなった．\n数値計算プログラムは一昔前はFortranやC言語で書かれることが多かったが，学術目的ではMATLABやPython(+NumPy&SciPyライブラリ)などの記述しやすい言語が使われることが増えてきたように思われる．\nzbmathの Software での引用数：","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"言語 引用数(2021) swMATH ID\nMATLAB 772 558\nPython 179 14460\nJulia 100 13986","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"MATLABやPythonはプログラムを書きやすいが，インタプリタ型言語ゆえに実行速度が遅いというデメリットがある．\nJulia言語ではJITコンパイルなどの現代的な技術を駆使して，プログラムの書きやすさと実行速度を高度なレベルで両立させている．","category":"page"},{"location":"index.html#特徴","page":"はじめに","title":"特徴","text":"","category":"section"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"文法・構文に関してはMATLABから大きな影響を受けている．\nMATLABと同様に数学関数，有理数，複素数，任意精度計算，線形代数，などの数学に関する多数の機能が標準で実装されている．\nMATLABはプロプライエタリ（ソースコード非公開）であるが，Julia言語はオープンソース \nMATLABやPythonはインタプリタ型（＋動的型付け）なのでコードを簡潔に書きやすいが，その代償として実行速度が遅くなる． Julia言語はJITコンパイル等により実行速度の損失を小さく抑えている．実際に，最速のC言語と比べてもおよそ数分の1と評価されている．[2]","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"[1]: https://julialang.org/blog/2018/08/one-point-zero/ ","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"[2]: https://julialang.org/benchmarks/","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"note: Note\nJulia言語は数値計算に最適なプログラミング言語であるが， 数値計算用に特化されているわけではないし， 他の言語ではできないことを可能にするような魔法の言語ではない．   これは裏を返せば，Julia言語に関する知識の大部分は普遍的で他言語で通用するということでもある．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"note: Note\nJuila言語ではプログラムの初回実行時にJITコンパイルが行われる．初回は（JITコンパイル）＋（プログラムの実行時間）がトータルの実行時間になるので，遅く感じるかもしれない． 2回目以降はJITコンパイルは行われないので，プログラム本来の実行時間になる．","category":"page"},{"location":"index.html#参考文献","page":"はじめに","title":"参考文献","text":"","category":"section"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"公式サイト: The Julia Language\n公式ドキュメント(en) ：ここに全て書いてあるので検索してください．\n進藤・佐藤: 「1から始めるJuliaプログラミング」コロナ社，2020.  本学では電子版が閲覧可：Maruzen eBook\nKalicharan: Julia - Bit by Bit, UTICS, Springer, 2021.  SpringerLink(Tulips経由)","category":"page"},{"location":"index.html#Juliaの起動","page":"はじめに","title":"Juliaの起動","text":"","category":"section"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"全学計算機システムのWindows端末（あるいはリモートデスクトップ） で実行する方法について説明する．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"Windows端末にログイン後，Windowsメニューから Juliaのアイコンを見つけて起動する． あるいは，検索窓から juliaとタイプした方が早いかもしれない．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"起動したら，まず，カレントディレクトリを確認する．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"julia> pwd()","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"ここでユーザーフォルダー C:¥¥Users¥¥〈ユーザー名〉 と表示されれば問題ないが， 私がリモートデスクトップで試した限りでは， C:¥¥Users¥¥Administrator と表示されるので注意が必要である．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"フォルダー移動は cd() (change director) コマンドで行う．cd()は引数無しで実行すると ユーザーフォルダーに移動する．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"julia> cd()","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"このあと，pwd()でカレントディレクトリを再度確認．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"julia> pwd()","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"C:¥¥Users¥¥〈ユーザー名〉が出力されれば大丈夫である． もちろん，cd(\"C:¥¥Users¥〈ユーザー名〉\")とベタ打ちしてもよい．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"次に適当なテキストエディタ，例えば Visual Studio Codeなどで， 次の内容でテキストファイルを作成し，hellow.jlという名前で保存する．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"println(\"Hello, world\")","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"Juliaのターミナルに移動して","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"julia> include(\"hellow.jl\")","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"を実行すると，Hello, world と表示されるはずである．","category":"page"},{"location":"index.html#Jupyter-Notebook-(本講義では非サポート)","page":"はじめに","title":"Jupyter Notebook (本講義では非サポート)","text":"","category":"section"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"Windowsメニューから Jupyter Notebookを起動する． ブラウザが立ち上がり，カレントフォルダのファイルリストが表示される． 左上側にある Newのプルダウンメニューから Julia 1.7.2 を選択する． そうすると，Juliaカーネルが起動した状態で空の \"ノートブック\" が表示される．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"<img src=\"jupyter-nb-kernel2022.png\" width=\"50%\">","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"In [ ]: の右側に versioninfo() と入力して Shift+Enterを押下するとコマンドが実行される． 以下のように表示されていれば正常と思われる．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"Julia Version 1.7.2\nCommit bf53498635 (2022-02-06 15:21 UTC)\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: Intel(R) Xeon(R) CPU E5-2699 v4 @ 2.20GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, haswell)\nEnvironment:\n  JULIA_DEPOT_PATH = Z:\\.julia-w","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"プログラムと実行結果がひとつのファイルに収まるし， MarkdownでLaTeXによる数式も記述できるので便利である． レポート提出用のpdfファイルも，メニューFile> Download as > HTML (.html) で変換したhtmlファイルを 印刷でpdfに変換すれば簡単に生成できる．","category":"page"},{"location":"index.html","page":"はじめに","title":"はじめに","text":"しかし，現時点では安定した環境であると言い切れないので，本講義ではサポートできない．","category":"page"},{"location":"04_条件分岐.html#条件分岐","page":"条件分岐","title":"条件分岐","text":"","category":"section"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"変数の値によって処理を変えたい場合， if ... [elseif ... else ...] end を用いる．  ","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"例えば，変数 x が x>0 であるときに \"positive\" と表示するには， 次のように記述する．","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"x = 1\nif x>0 \n    println(\"$x is positive.\")\nend","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"x < 0 のとき \"negative\" と表示する場合は，elseif で条件式を追加すればよい．","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"x = -2\nif x > 0 \n    println(\"$x is positive.\")\nelseif x < 0                      # 追加\n    println(\"$x is negative.\")    # 追加\nend","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"x<0 でも x>0 でもないときは，x は 0 と言いたいところだが，それ以外の可能性もあるので，  else を用いて次のように書いておこう．","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"x = NaN\nif x > 0 \n    println(\"$x is positive.\")\nelseif x < 0\n    println(\"$x is negative.\")\nelse                                      # 追加\n    println(\"$x is zero or something.\")   # 追加\nend","category":"page"},{"location":"04_条件分岐.html#数値に関する等号と比較演算子","page":"条件分岐","title":"数値に関する等号と比較演算子","text":"","category":"section"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"数値どうしを比較する演算子は次の通り．","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"プログラム 条件式\nx == y x=y\nx != y xneq y\nx > y x  y\nx >= y x ge y","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"論理積（and）は &&，論理和 (or) は || が対応している．例えば，","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"1 < 2 && 2 < 3","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"これは次のように書くこともできる．","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"1 < 2 < 3","category":"page"},{"location":"04_条件分岐.html#短絡評価","page":"条件分岐","title":"短絡評価","text":"","category":"section"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"x=1\nif x > 0 \n    println(\"$x is positive.\")\nend","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"は && を用いて次のように書くことも多いようである．","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"x=1\nx>0 && println(\"$x is positive.\")","category":"page"},{"location":"04_条件分岐.html","page":"条件分岐","title":"条件分岐","text":"最初に x>0 の評価が行われ， true ならばもう片方の評価が行われる．つまり，println 部分が実行される． もし，false ならば，残りの条件式の評価はスキップされる．","category":"page"}]
}
