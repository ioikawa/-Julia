# 配列: [Array](https://docs.julialang.org/en/v1/manual/arrays/)
次のように複数の変数を1列に並べて， `[...]` で囲ったものを配列という．

```@repl
A = [1, "two" , 3, "z"]
length(A)   # 配列の要素数を取得
```

配列の左から`i`番目の要素にアクセスするには，`A[i]`と書く．
```@repl
begin
A = [1, "two" , 3, "z"]
println(A[1])
println(A[2])
println(A[3])
println(A[4])
end
```



配列の先頭と末尾の要素はそれぞれ `A[begin]`, `A[end]`と書いてアクセスできる．

```@repl
A = [1, "two" , 3, "z"];
A[begin]
A[end]
A[end-1] 
```

## コロンによる配列の抜き出し
例として整数の連番からなる配列を考える．
```@repl
A = collect(1:10)     # A = [1,2, ..., 10]
```
`1:10`は1,2,...,10 という範囲を表す．
`collect()`で範囲が配列に変換されたということである．

次のように書いても同じである．
``` @repl
A = Vector(1:10)
```

配列の一部分にまとめてアクセスしたい場合は，`A[範囲]`の形で書く．
```@repl
A = collect(1:10)
A[3:6]      
A[1:3:end]    # 1 から end まで 3刻みの範囲
```

## 配列同士の連結
２つの配列`A`, `B` を連結させる場合は，`[A; B]` あるいは `vcat(A,b)`とすればよい．
```@repl
A = [1,2,3]
B = ["a", "b", "c"]
[A; B]
vcat(A, B)
```

## 要素の push と pop
配列の末尾に要素を追加するには `push!(配列, 追加する要素)`を用いる．
関数名に`!`がついているのは，引数を変更する関数であることを表している．
```@repl
A = [1,2,3,"z"];
push!(A,4)
push!(A,"a","b","c",["あ", "い", "う"])
```

配列の末尾から要素を取り出すには `pop!`を用いる．

```@repl
A = [1,2,3,"z"];
pop!(A)
A  # 取り出したものは無くなっているはず
```

一部分を取り出したい場合は`splice!`が使える．
```@repl
A = [1,2,3,4,5]
splice!(A,2:4)   # A[2:4]を取り出す
A   # 確認のため表示．取り出した部分は残っていない
```

## 配列の参照とコピー：`deepcopy`
Julia言語では，配列のコピーは **参照コピー**である．
つまり，配列の要素が記録されているメモリアドレスのコピーになる．
次の例を見れば参照がどういうものかわかると思う．
```@repl
a = [1,2]
b = a     # 参照のコピー
a[1] = 100   
@show a, b;  # aを変えるとbも変わる
b[2] = 200 
@show a, b;  # bを変えるとaも変わる
```

配列を複製してコピーするには `deepcopy()`を用いる．
```@repl
a = [1,2]
b = deepcopy(a)     # 配列そのものを複製
a[1] = 100   # bは書き換わらない 
@show a, b;  
b[2] = 200 　# aは書き換わらない
@show a, b;  
```

`deepcopy()`は配列がそのまま複製されるので，コピーするのに時間もかかるし，新たにメモリも確保されるので注意．
```@repl
a = [1,2]
@time b = a    # アロケーション（割当）は行われない
@time b = deepcopy(a)   # アロケーションされる 
```

## 浅いコピーと深いコピー
`deepcopy()`は配列に格納された値をすべてそのままコピーして新しい配列を生成する．
これは通常，**深いコピー (deepcopy)** と呼ばれる．
これに対して，**浅いコピー(shallow)** は各要素の参照をコピーする．
違いは次の例を見ればわかる．
まずは 深いコピーの挙動を見る．
```@repl
a = [1,2,[3,4]]
b = deepcopy(a)
a[1] = 100    # 1 を 100に
a[3][1] = 300   # [3,4] を [300, 4] に
@show a, b;   # bは何も変わっていない
```
次に浅いコピーの場合：
```@repl
a = [1,2,[3,4]]
b = copy(a)     # 浅いコピー
a[1] = 100    # 1 → 100に
a[3][1] = 300   # [3,4] → [300, 4] に
@show a, b;   # b[1]は変わっていないが，b[3]は変わっている
```
深いコピー`deepcopy(a)`の場合，`a` に配列が含まれている場合，その配列の中身も丸ごとコピーされて，
`b = [値, 値, [値, 値]]` となる．それに対して，
浅いコピー`copy(a)` の場合，`a`内の配列は参照がコピーされる：`b = [値，値，参照]` ．
この結果，`b[3]`は `a[3] = [3,4]` への参照となる．


!!! note
    Julia言語やC/C++, Pythonでは，`配列=配列`は参照コピーになる．
    一方で，FortranやMATLABでは値コピーになるので，注意が必要である．
    値コピーの方がコードの挙動がわかりやすいが，
    無頓着に書きならべると無駄なアロケーションを発生させてしまう可能性がある．
    例えば，与えられた配列`a`に対して，
    ```
        b = a        # 参照コピー
        c = a        # 参照コピー
        x = b + c    # 配列生成（アロケーション1回目）
    ```
    というコードを考えてみよう．Julia言語の場合は上のコメントに書いてあるとおり，
    上2行は参照コピーで，3行目で新たに配列が生成されるので，アロケーションは1回だけである．
    もし，仮に`=`が値コピーを行う場合は，上記コードは次と等価になる．
    ```
        b = copy(a)      # 値コピー（アロケーション1回目）
        c = copy(a)      # 値コピー（アロケーション2回目）
        x = b + c        # 配列生成（アロケーション3回目）
    ```
    この場合，アロケーションは3回発生する．
    （しかし，そもそも `x = a + a`と書けば無駄なアロケーションは発生しないので，
    上の例はあまり意味が無い．もっと良い例はないか？）

## 配列に対する関数

```@repl
A = [1,2,3,4,5]
sum(A)      # 配列の要素の総和
prod(A)     # 総乗
maximum(A)  # 最大値
minimum(A)  # 最小値
```

## dot 演算子：要素ごとの操作
配列`A`の要素ごとに演算，あるいは関数を作用させたい場合，
dot演算子 `.` を用いる．
```@repl
A = [1,2,3,4,5]
A .+ 1     # [1+1, 2+1, 3+1, 4+1, 5+1]
A .^ 2     # [1^2, 2^2, 3^2, 4^2, 5^2]
sqrt.(A)   # [sqrt(1), sqrt(2), sqrt(3),sqrt(4),sqrt(5)]
```

## 空の配列
```@repl
empty_array = []   # 空の配列．任意の型の変数を
vec = Float64[]    # 要素の型を指定する
```

## 配列の生成
```@repl
zeros(3)         # `0`が3個の配列
ones(3)          # `1`が3個の配列
fill("abc", 3)  # "abc"が3個の配列
```

# 配列とループ処理

## 配列によるforループ
`A`を配列とする．for ループに範囲において`x in A`と書くと，
`x`が配列`A`の先頭から末尾へと動くようなループが書ける．

```@example
A = [1,[2],"three"] 
for x in A 
    @show x
end
```

## 要素番号の取得: `enumerate`
カウンタ変数が配列内を動くとき，要素の中身だけでなく番号も取得したい場合もある．
その場合は，`enumerate()` を使う．
```@example
A = [1,[2],"three"] 
for (i,x) in enumerate(A) 
    @show i,x
end
```

## 内包表記 (Comprehensions)
`A = [1,2,3,4,5]`のような連番からなる配列は，次のようにして生成できる．

```@repl
A = [i^2 for i in 1:5]
```
このように配列内で for ループを用いて配列を定義する方法を内包表記という．

`A = [1,4,9,16,25]`のような $i$ 番目の要素が $i^2$ であるような配列を，
任意の長さで作成したい場合などは，次のような forループを用いた内包表記が使える．

```@repl
n = 10
A = [i^2 for i in 1:n]
```

## BitVector による部分配列の抽出
例として，実数の要素からなる配列 `A` から，正の値をもつ要素だけを取り出すことを考える．
これは次のようにインデックスに条件式を与えることで実現できる．
```@repl
A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i
A[A .> 0]
```

これの仕組みをもう少し具体的に見てみよう．
配列のインデックスに，`0` or `1` の要素のみを含む配列
`BitVector`を渡すと，`1`の要素に対応する部分配列を抽出できる．

```@repl
A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i
idx = BitVector([0,0,0,1,1,1])   
A[idx]  
```

`A .> 0` は`A`の要素ごとに 条件式`>0`を適用し，`true`の場合は`1`を，`false`の場合は`0`を返す．
結果は `BitVector`型の配列となる．

```@repl
A = [0, -1, 2, -3, 4, -5];  # a_i = (-1)^i
idx = A .> 0
A[idx]       # A[A.>0]と等価
```

## 特定の値の除去
配列から `missing`（統計データの欠損を表す値）を取り除く処理を考える．
値が`missing`かどうかの判定には`ismissing()`を用いる．
```@repl
ismissing(missing)
ismissing(100)
```
`.ismissin.(A)`で `missing`を含む要素の`BitVector`が得られるので，これを
`.!` で反転させて抽出する．
```@repl
A = [1,2,missing,4,missing]
A[.!ismissing.(A)]   
```

`.!ismissing.`は `(!ismissing).`と書くこともできるし，
`map()`を使ったほうが場合によっては見やすい．
```@repl
A = [1,2,missing,4,missing]
A[(!ismissing).(A)]   
A[map(!, ismissing.(A))]   
```

